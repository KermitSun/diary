# CAP定理、BASE、幂等操作

## CAP定理
1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标，即C\A\P;

所谓CAP定理，指的是：在网络分区时，不能同时保证可用性和一致性

### 何谓CAP
C即Consistency(一致性)，分布式服务器之间，值保持一致性；

P即Partion Tolerance(分区容错),分区容错表示区间通信可能失败；

A即Availablity(可用性)，服务一直保持可用的状态，当用户发出一个请求，服务能在一定的时间内返回结果；

### A和C的冲突
如果服务器A同步信息到服务器B，用以保证一致性，此时发生分区容错，则为保证一致性，
服务器B的该条数据需要被锁定，这时候服务器B保证不了可用性；

同理，如果为了保证可用性，则服务器A和B则不能保证一致性；

### A和C的衡量
#### 可用性高于一致性
对于有些业务，数据的新旧都可以接受，这时候可用性高于一致性，比如平时浏览的网页；

#### 一致性高于可用性
对于某些业务，尤其是数据信息，需要保证数据一致性，比如加锁，即使牺牲一些时间，也要保证一致性，防止出现脏数据等情况；

## BASE
BA:Basic Availability 基本业务可用性；

S: Soft state 柔性状态；

E: Eventual consistency 最终一致性；

### 分布式事务如何保证最终一致性
1. 单数据库事务
    
    直接通过数据库的事务来保证最终一致性；

2. 多数据库事务
    
    针对多数据库事务可以根据二阶段提交协议，采用spring 3.0 + Atomikos + JTA进行支持； 

3. 基于事务型消息队列的最终一致性
     
     借助消息队列，在处理业务逻辑的地方发送消息，业务逻辑处理成功后，提交消息，确保消息是发送成功的，之后消息队列投递来进行处理，如果成功，则结束，如果没有成功，则重试，直到成功，不过仅仅适用业务逻辑中，第一阶段成功，第二阶段必须成功的场景。
     
4. 基于消息队列+定时补偿机制的最终一致性

    前面部分和上面基于事务型消息的队列，不同的是，第二阶段重试的地方，不再是消息中间件自身的重试逻辑了，而是单独的补偿任务机制。其实在大多数的逻辑中，第二阶段失败的概率比较小，所以单独独立补偿任务表出来，可以更加清晰，能够比较明确的直到当前多少任务是失败的。
    
5. 异步回调机制的引入

     A应用调用B，在同步调用的返回结果中，B返回成功给到A，一般情况下，这时候就结束了，其实在99.99%的情况是没问题的，但是有时候为了确保100%，记住最起码在系统设计中100%，这时候B系统再回调A一下，告诉A，你调用我的逻辑，确实成功了。其实这个逻辑，非常类似TCP协议中的三次握手。
     
6. 类似double check机制的确认机制

    还是上图中异步回调的过程，A在同步调用B，B返回成功了。这次调用结束了，但是A为了确保，在过一段时间，这个时间可以是几秒，也可以是每天定时处理，再调用B一次，查询一下之前的那次调用是否成功。例如A调用B更新订单状态，这时候成功了，延迟几秒后，A查询B，确认一下状态是否是自己刚刚期望的。
    
## 幂等性
一个请求，不管重复来多少次，结果是不会改变的；

### 如何保证幂等性
消息里要有一个唯一标识；
1. 先查询是否有该条信息，是否做了该更改，如果没有，再更改，一般适用于插入和删除，以及要求并发程度不高；

2. 业务表添加唯一约束；

3. 添加一个消息表，每次执行前先插消息表，唯一标识做主键；

4. redis里记录消息ID；

5. 使用分布式锁对消息id加锁；

### 幂等性的使用范围
1. mq防止重复消费

2. 表单防止重复提交

3. 乐观锁
