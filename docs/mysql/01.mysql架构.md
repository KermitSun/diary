<h1 align="center">mysql架构</h1>

源自：极客时间 林晓斌老师讲解的《mysql实战45讲》，这里是心得笔记

# 1.mysql架构
mysql大体可分为两部分，Server层与存储引擎两部分。

存储引擎负责数据的提取和存储，其设计为插件式，有InnoDB、MyISAM、Memory等多个存储引擎,mysql5.5.5之后默认是InnoDB引擎。

Server层则是客户端和存储引擎的中间层，包含连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能,以及所有的内置函数，所有跨存储引擎的功能都在这里实现，如存储过程、触发器、视图等。

# 2.Server层
sql按照以下顺序执行

## 2-1.连接器
    负责客户端连接mysql服务器，验证用户名密码、客户端权限。
    连接采用tcp握手连接。
    连接后，会缓存其用户信息及权限信息，所以其他用户对其权限的修改，不会影响现有连接，只有重新连接后才会更改权限。
    默认8小时不操作后断开连接（长连接）。
    过多长连接会导致内存占用过多，因sql执行中的缓存是放在连接里的，最终可能会导致oom，mysql异常重启。
    针对上述问题，解决方法有两个：1.定期断开长连接用于清理缓存；2.mysql5.7及之后版本，执行命令mysql_reset_connection初始化资源，其不会重连和权限验证。
    
## 2-2.查询缓存
    执行的sql结果会缓存到该空间里，下次查询如果能够命中缓存缓存，则直接返回结果。
    查询缓存以key-value形式存在，key是查询sql，value是查询结果。
    一张表执行了Create、Update、Delete操作后会清空查询缓存，所以经常变动的表没必要开启查询缓存。
    禁止查询缓存，设置query_cache_type为DEMAND禁止查询缓存，同时可以在sql中加入SQL_CACHE显式使用查询缓存。
    eg:select SQL_CACHE * from T;
    
## 2-3.分析器
    没有命中查询缓存，则进入分析器。
    分析器会对sql进行语法分析，如果语法错误则返回"You have an error in your SQL syntax"
    判断sql的类型，CUSD中的哪个，sql中的字段与表中字段对应上。
    
## 2-4.优化器
    选择索引；
    多个表关联查询时候，重排序关联顺序；
    
## 2-5.执行器
    判断该用户对该表是否有执行该sql的权限；（为什么不在分析器阶段判断权限？因有些sql是调用存储过程、触发器等操作，该操作需要执行器阶段才能确定）
    如果是select的sql；
    eg:select * from T where id = 3;
    如果id不是索引的话，调用引擎接口获取第一行，如果id=3则放入结果集中，不满足则跳过；
    如果id是索引的话，引擎会直接定位到第一个id=3的那一行并返回；
    之后执行器继续调用引擎接口，知道获得所有的结果集，并返回给客户端。
    如果是update的sql；
    先查询，先执行查询流程，获得后在执行器里计算新值，然后再逐个调用引擎接口更新；
    
# 3.redo log日志与binlog日志
针对更新操作，有redo log和binlog需要了解。

mysql采用WAL技术，即Write-Ahead—Loggin技术，其特点是先写日志，再写磁盘。

# 3-1. InnoDB的redo log日志
redo log是InnoDB引擎里的，所以其运行在存储引擎层。

针对一条更新，会先记录在redo log中，然后更新内存，等mysql服务器空闲时候，才会将其更新到磁盘。 

redo log记录了对该行数据做了什么操作(具体也不了解 todo以后完善)。

InnoDB的redo log是固定大小的，会循环写入，如果redo log满了，则会主动把最前头的部分写入磁盘，之后擦除。

有了redo log，即使mysql服务异常重启，提交的部分也不会丢，该能力称为crash-safe。
    
# 3-2. Server层的binlog日志
binlog在Server层，所有引擎都记录该日志；
    
binlog有两种格式，statement格式记录了sql，row格式记录更新前后的行数据；

binlog日志是追加的，一份文件写完了会切换到下一个文件，并不会覆盖以前的；

binlog日志是执行器记录的；

# 3-3. 两段式提交
更新过程：
- 执行器获取数据；
- InnoDB返回数据（先在InnoDB内存中获取）；
- 执行器对数据进行计算，之后把计算后的值发送给InnoDB；
- InnoDB将新数据放入内存中，记录redo log，此时该日志处于prepare状态，告诉执行器执行完毕；
- 执行器记录binlog，把binlog写入磁盘，执行器调用InnoDB提交事务接口；
- InnoDB将redo log改为commit状态，更新完成；

两段式提交是为了保证redo log和binlog一致。

innodb_flush_log_at_trx_commit设置为1，则每次redo log直接写到磁盘。
sync_binlog 设置为1，每次binlog直接写到磁盘。

# 3-4 为什么mysql可以回退到之前的状态
mysql需要定期保存快照，然后寻找到回退时间之前最近的快照，之后通过binlog执行sql到达回退时间。


    
    


