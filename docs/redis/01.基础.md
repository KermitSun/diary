# redis基础

## redis为什么这么快
10w+QPS(每秒内查询次数)
1. 基于内存
2. 没有关系型数据库的关联关系
3. 采用单线程，不用切换线程
4. 使用多路I/O复用模型，非阻塞IO

## redis类型
- String
    - set key "value" 存值
    - get key  取值
    - incr key 自增,从1开始
- Hash hash结构
    - hmset Lilei name "lilei" age 26 sex 1 保存hash对象Lilei
    - hset Lilei name "hanmeimei" 保存hash里的一个值
    - hget Lilei name 获取hash里的一个值
- List 有序列表
    - lpush listName aaa 创建数组listName，aaa放入列表最前
    - rpush listName bbb 将bbb放入列表最后
    - lrange listName 0 10 取出listName中从0开始，一共取10个，后进先出
    - lpop listName 返回第一条信息，并将其从list中清除
- Set 无序集合,不重复
    - sadd myset 111 将111放入名为myset的set里
    - smembers myset 展示myset里所有元素
    - 求两个set的交集并集差集的命令....
- Sorted Set 按照权重排序的集合，由小到大,不可重复
    - zadd myzset 3 abc 权重为3的值abc放入myzset里
    - zrangebbyscore myzset 0 10 从小到大取10个
        
## 从海量数据中获取某一前缀的key
- dbsize 查询redis中有多少个key

1. 使用keys pattern 通过正则找到所有符合的key
    eg: keys k1* 返回所有k1为前缀的key；
    
    keys命令如果返回很多，会造成服务器卡顿；

2. SCAN cursor [MATCH pattern] [COUNT count]
    eg:scan 0 match k1* 10 返回k1为前缀的key的前十个；
    
    基于游标(cursor)的迭代器，需要上一次的游标继续迭代；
    以0作为游标开始一次新的迭代，知道命令返回游标0完成一次迭代；
    不保证每次执行都返回某个给定数量的元素，支持模糊查询；
    一次返回的数量不可控，只能大概率符合count参数；
    
## 如何通过redis实现一个分布式锁

setnx key value 如果key不存在，则创建并赋值
expire key seconds 对key设置过期时间，seconds是秒级

两个命令实现过期时间的分布式锁，但是两个命令非原子性的，如果第一个命令执行完后，redis挂掉了，
那么将永远锁住

2.6redis之后支持了新的set命令

SET key value [EX seconds][PX milliseconds][NX|XX]
- EX 设置秒级过期时间
- PX 设置毫秒级过期时间
- NX 只有键不存在时，才对其进行操作
- XX 只有键存在时，才对其进行操作
- SET成功后返回ok，否则返回nil

## 大量的key同时过期的注意事项
集中过期，大量删除key，redis会出现短暂的卡顿现象；

解决方案，在过期时间设置时候，加入随机的毫秒值，来防止同时过期；

## 如何实现异步队列
1. 使用List作为队列，rpush生产消息，lpop消费消息
    - 不能主动消费；
    - 只能有一个消费者；
    - 可在java中循环调用方式一直调用lpop；

2. 使用List作为队列，使用blpop阻塞获取消费消息
    - eg: blpop mylist 30 获取mylist中最前的消息，没有则等待30s，直到有为止；
    - 缺点：只能有一个消费者；
    
3. 使用sub/pub 主题订阅者模式