#服务于换粗你的问题
微服务架构的特点就是:“一解释就懂，一问就不知，一讨论就吵架”;
##服务降级、服务熔断
### 服务降级
将服务设置权重，当服务器过载时，适当关闭一些权重程度不高的服务，保证高权重的服务正常运行；

### 服务熔断
当服务过载时候，未防止系统崩溃，造成未知问题，将该服务暂时关闭；

## 缓存穿透、缓存雪崩、缓存击穿、缓存预热

###缓存穿透
#### 定义
用户访问服务时候，应先访问缓存服务器获取数据，当缓存服务器无用户所需数据时候，再去访问数据层，
这种透过缓存访问数据库的行为称为缓存穿透；
#### 后果
有些黑客利用缓存穿透，不断访问不存在的资源，而造成频繁的缓存穿透，以致数据库宕机；
#### 解决方案
1. 布隆过滤器，将所有可能存在的资源保存到一个足够大的bitmap中，一个一定不存在的访问会被布隆过滤器拦截；
2. 将不存在的资源也放入缓存，并设置过期时间，这样多次访问的时候，除开第一次之后的都会访问缓存服务器；

### 缓存雪崩
#### 定义
缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩；
#### 后果
宕机呗
#### 解决方案
1. 采用加锁或队列的方式，防止大量并发同时到达db；
2. 对缓存时间加入随机值；

### 缓存击穿
#### 定义
当热点数据缓存失效，新的数据未刷新到缓存时候，有大量并发访问，造成db访问量突然增高；

缓存雪崩针对大量key同一时间失效，而缓存击穿针对一个key失效时候并发访问很高的情况；

#### 解决方案
1. 使用互斥锁(mutex key)

    当访问缓存服务器未得到资源时，首先调用分布式锁，查看是否加锁，未加锁则加锁，并刷新缓存，
刷新完成后解锁，再次去缓存服务器获取资源；

2. "提前"使用互斥锁(mutex key)

    资源上加入建议更新缓存的时间戳，访问资源后，获取其建议更新缓存时间戳，如果当前时间超过时间戳，则更新缓存，当然，这些操作也需要加入分布式锁；
    
3. 永不过期
    
    方案1、缓存里保存的资源不设置过期时间；方案2、在定时任务里定时刷新缓存，要打好提前量；
    
4. 资源保护
    
    采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可； 
 
### 缓存预热
#### 定义

#### 解决方案 