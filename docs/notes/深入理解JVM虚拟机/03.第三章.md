# 第三章 垃圾收集器与内存分配策略

## 3.1 概述
垃圾收集器(Garbage Collection, GC),1960年诞生于MIT的Lisp，历史比Java久远；

### GC的作用
程序计数器、虚拟机栈、本地方法栈随着线程产生而存在，线程死亡而消亡，栈中栈帧随着方法
进入和退出有条不紊的入栈和出栈操作，每一个栈帧分配多少内存在类结构确定下来时已经知道
(运行期JIT会进行一些优化，目前可认为是编译器可知的)，因此这几个区域的内存分配和回收都有确定性，
不需要过多考虑回收的问题；

而Java堆和方法区则不一样，一个接口的多个实现类需要的内存不一样，一个方法中多个分支需要的内存也不一样，
我们只有在程序运行期间才能知道会创建哪些对象，这部分的内存分配都是动态的，垃圾收集器关注的就是这部分；

## 3.2 对象已死么
Java堆中保存着几乎所有的对象实例，垃圾收集器在对堆中对象回收前，首先检查哪些对象存活，哪些对象已经死去(不可能再被任何途径使用)；

### 3.2.1 引用计数算法 Reference Counting
给对象添加一个初始值为0的计数器，每当有一个地方引用它，计数器+1，当引用失效时候，计数器-1，任何时刻计数器为0的对象就是不可能再被使用的；

引用计数算法是一种实现简单，判定效率高的算法，但其不能解决对象循环引用的问题；

### 3.2.2 可达性分析算法 Reachability Analysis
通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始往下搜索，搜索所走过的路径称为引用链(Reference Chain),
当一个对象到GC Roots没有任何Reference Chain相连，则认为该对象是不可用的；

Java中可作为GC Roots的对象:
- 虚拟机栈(栈帧中的本地变量表)中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI(即一般所说的native方法)引用的对象；

### 3.2.3 再谈引用
在jdk1.2之前的引用的定义：如果reference类型的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表着一个引用；
但是这种定义太过狭隘，一个对象只能有引用和未引用两种状态；对于一些“食之无味，弃之可惜”
的对象，内存足够时候，应保持引用，gc后内存依然不足的，则可以回收这些对象；

1.2之后，Java对引用的概念进行扩展，分为4种，这四种引用强度依次主键减弱：
- 强引用(Strong Reference) 在程序代码中普遍存在的，类似“Object a = new Object()"这类的引用，
只要强引用还存在，垃圾收集器就不会回收被引用的对象；
- 软引用(Soft Reference) 用来描述一些还在用但非必要的对象；对于软引用关联的对象，
在系统即将发生内存溢出之前，会将这些对象放入回收范围之内，进行二次回收，如果这次回收后，
依然没有足够内存，则会抛出内存溢出；jdk1.2之后，提供SoftReference类来实现引用；
- 弱引用(Weak Reference) 用来描述非必须对象；被弱引用关联的对象只能存活到下一次gc之前，无论内存是否足够，
被弱引用引用的对象都将被回收；jdk1.2之后提供了WeakReference类来实现弱引用；
- 虚引用(Phantom Reference) 也成为幽灵引用或幻影引用，是最弱的一种引用关系；一个对象是否有虚引用，完全不会对其生命周期有影响，
也无法通过虚引用来获取对象实例；为一个对象设置虚引用，只会在这个对象被回收时候收到一个系统通知；jdk1.2之后，
提供了PhantomReference类实现虚引用；

### 3.2.4 生存还是死亡
即使可达性分析算法中不可达的对象，也并非是“非死不可“的，这时候它们处于”缓刑”阶段，真正宣告一个对象死亡，
需要经过两次标记过程：

> 第一次标记

如果对象没有于GC Roots相关联的引用链，name它将会第一次被标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法，
当对象没有覆盖finalize()方法，或者finalize()方法已经被jvm吊用过，虚拟机都将视为“没有必要执行”；

如果有必要执行finalize()方法，这个对象将被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机创建的、低优先级的Finalizer线程去调用F-Queue中的对象的finalize()方法；
但是jvm并不保证会等待它运行结束；因为finalize()方法可能会执行缓慢或者发生死循环,导致F-Queue后边的对象处于永久等待，甚至导致整个内存回收系统崩溃；

> 第二次标记

稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象变为在引用链上，则将其移出即将回收的集合，如果对象没能逃脱，
未能在引用链上，那基本上它就真的被回收了；

gc回收的代码[查看代码](https://github.com/KermitSun/practice/blob/master/java/jvm/第三章/FinalizeEscapeGC.java)

从代码可以看出，SAVE_HOOK对象的finalize()确实被GC收集器触发过，并且在收集前成功逃脱，而第二次gc时候，并不会调用finalize(),所以对象被回收了；

不建议使用finalizy()方法拯救对象，因为它不像C/C++中的析构函数；其运行大家高昂，不确定性大，无法保证各个对象的调用顺序；

### 3.2.5 回收方法区
方法区(HotSpot中的永久代)的回收性价比不高，Java虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾收集，方法区的垃圾回收主要是两部分，废弃常量和无用的类；

对于废弃常量的判断较为简单，以常量池中字面量做例子，如果一个字符串"abc"已经进入常量池，但是当前系统没有任何一个String对象引用常量池中的"abc"常量,那么发生内存回收时候，
如果有必要，该常量就会被清理出常量池；

对于无用的类的判断，则要复杂很多，需要同时满足以下要求：
- 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；

虚拟机可以对满足上述3个条件的无用类进行回收，但不是必然，HotSpot通过-Xnoclassgc参数设置是否回收；

## 3.3 垃圾收集算法
### 3.3.1 标记-清除算法 Mark-Sweep
算法分为"标记"和"清除"两个阶段，首先标记出所有需要回收的对象，然后统一回收所有被标记的对象，它的标记过程就是前一节讲的两次标记过程；

标记清除算法的不足：
- 效率慢，标记和清除的过程效率都不高；
- 空间利用率低，标记清除后会产生大量不连续的内存碎片，后续如果程序申请一个较大对象空间时候，无法找到一块足够的内存空间，就会触发再一次的垃圾收集动作；

### 3.3.2 复制算法 Copying
为了解决效率问题，复制算法出现了，它将可用内存按容量分为大小相等的两部分，每次只使用其中一块；当这块内存用完了，就将还存活着的对象复制到另一块上面，
然后把当前的内存块一次清理掉；

复制算法不会产生内存碎片，分配新的内存时候，也只需要指针碰撞就行了，实现简单，运行高效；

其不足是内存缩小为原来的一半，代价较高；

现在的商用虚拟机都是采用复制算法来回收新生代的，新生代中98%的对象都是朝生夕死的；

虚拟机实现复制算法时，并不是按1:1分配两块内存空间，而是分为了一个较大的Eden空间和两个较小的Survivor空间，每次只使用一个Eden和一个Survior空间，
当垃圾回收时，将两块空间存活的对象一次性放入另一个Survivor空间，并清理当前的两个内存空间；

HotSpot默认的Eden和Survivor的比例是8:1，这样新生代的内存空间只会浪费10%；当Survivor空间不足，不足以存放存活对象时候，
需要依赖其他内存空间(这里指老年代)进行分配担保(Handle Promotion);

### 3.3.3 标记-整理算法 Mark-Compact
标记-整理算法分为"标记""清除"和"整理"，标记-清除如同之前，最后会进行整理，将所有存活的对象左移，取消内存碎片；

### 3.3.4 分代收集算法 Generational Collection
当前商业虚拟机的垃圾收集都采用“分代收集”算法，其根据对象的存活周期的不同将内存划分为几块；一般讲Java堆分为新生代和老年代，
根据各个年代不同特点采用不同垃圾收集算法；

在新生代中，每次垃圾收集都会发现大批死去的对象，只有少量存活，所以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，
而老年代中对象的存活率高、没有额外空间对它进行分配担保，就必须采用"标记-清除"或"标记-整理"算法来进行收集了；

## 3.4 HotSpot的算法实现
### 3.4.1 枚举根节点
可达性分析中，从GC Roots的节点分析所有引用，是很耗时的操作；另外，为了保证GC时候的一致性，所以分析时候必须停顿所有Java执行线程，
Sun将这个事情称为“Stop The World”，即使号称(几乎)不会发生停顿的CMS收集器中，枚举根节点也是必须停顿的；

在HotSpot的实现中，在类加载完成后，HotSpot就把对象内什么偏移量上什么类型的数据计算出来，在JIT编译过程中，
也会在特定位置记录下栈和寄存器中哪些位置是引用；这些数据保存在一个叫做OopMap的数据结构中；

当HotSpot发生GC时，直接扫描OopMap就可以知道引用情况了；

### 3.4.2 安全点 Safe Point
在OopMap的帮助下，HotSpot可以快速且准确的完成GC Roots枚举，但是一个很现实的问题，能够引起OopMap变化的指令非常多，如果为每一条指令都生成对应的OopMap，
那GC的空间成本将非常高；

实际上，HotSpot也没有为每条指令生成OopMap，而是在“特定位置”记录了这些信息，这些位置称为“安全点”(SafePoint);

SafePoint的选定不能太少也不能太多，太少会使gc时间过长(因为要让所有线程跑到各自的安全点，安全点间隔过长会导致某些线程需要执行更多的时间，其他线程需要暂停等待它)，
太多会导致运行时的负荷；安全点的选定主要以“是否具有让程序长时间执行的特征”为标准选定的，“长时间执行”的最明显特征就是指令序列的复用，
比如方法调用、循环跳转、异常跳转等，所以具有这种功能的指令才会产生SafePoint；

SafePoint另一个需要考虑的问题是，如何在GC发生时让所有线程(不包含JNI调用的线程，JNI即Java Native Interface,意为Java本地接口)都跑到最近的安全点上再停顿下来；这里有两个方案可供选择：
- 抢先式中断(Preemptive Suspension)，不需要线程主动配合，在GC时首先把所有线程中断，如果发现有线程没在安全点上，则恢复其运行，让其跑到安全点；
现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而影响GC事件；
- 主动式中断(Voluntary Suspension)，在GC需要中断线程的时候，不直接对线程操作，仅仅设置一个标识，各个线程执行时主动轮询该标识，
发现该标识变为中断时候就主动挂起，而轮询标识的指令位置，就是安全点的位置(也就是说到达安全点时候就会轮询一下标识)，另外创建对象分配内存时候，
也会轮询标识；

### 3.4.3 安全区域 Safe Region

SafePoint解决了大部分线程的GC中断问题，但是另外一些，如果需要GC时，刚好程序不在执行，不能向后执行代码(线程处于Sleep或者Blocked状态,线程没有分配CPU资源，无法响应请求),
对于这种情况，就需要安全区域(SafeRegion)了；

安全区域指的是在一段代码片段中，引用关系不会发生变化，在这个区域内的任何地方GC都是安全的；

在线程执行到Safe Region中的代码位置时，线程首先标识自己已经进入了SafeRegion，当JVM发起GC时候，就不用管标识自己为SafeRegion的线程走向SafePoint了；在线程要离开SafeRegion时，
它要检查系统是否已经完成了根节点枚举(或者整个GC过程)，如果完成了，那么线程就继续执行，否则它就必须等待知道收到可以安全离开SafeRegion的信号为止；

## 3.5 垃圾收集器
如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现；

![jvm垃圾收集器](/resources/images/深入理解jvm虚拟机/jvm垃圾收集器.png)

图片展示了7种作用于不同年代的收集器，如果两个收集器之间存在连线，说明他们可以搭配使用；接下来将逐一介绍这些收集器的特性、基本原理和使用场景，重点分析CMS和G1这两款收集器；

### 3.5.1 Serial收集器
Serial收集器时最基本、发展历史最悠久的收集器，曾经(jdk1.3.1之前)是新生代唯一的收集器；这是一个单线程收集器，它只会使用一个CPU或一个收集线程去完成垃圾收集工作，
在垃圾收集时，必须暂停其他所有线程的工作；

Serial收集器(至jdk1.7)目前是Client模式下的默认新生代收集器，它的优势是：简单而高效(与其他收集器的单线程相比),Serial没有线程交互的开销，专心做垃圾收集，获得单线程的最大效率提升；

Serial收集器在新生代采用复制算法，暂停所有用户线程，老年代采用标记-整理算法，暂停所有用户线程；

### 3.5.2 ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了多条线程进行垃圾收集，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样；

ParNew收集器是许多运行在Server模式下的虚拟机的首选新生代收集器，其中一个与性能无关但很重要的原因是，它是错了Serial之外唯一能和CMS收集器配合工作的收集器；

### 3.5.3 Parallel Scavenge收集器
Parallel Scavenge收集器时一个新生代收集器，它
