# 第三章 垃圾收集器与内存分配策略

## 3.1 概述
垃圾收集器(Garbage Collection, GC),1960年诞生于MIT的Lisp，历史比Java久远；

### GC的作用
程序计数器、虚拟机栈、本地方法栈随着线程产生而存在，线程死亡而消亡，栈中栈帧随着方法
进入和退出有条不紊的入栈和出栈操作，每一个栈帧分配多少内存在类结构确定下来时已经知道
(运行期JIT会进行一些优化，目前可认为是编译器可知的)，因此这几个区域的内存分配和回收都有确定性，
不需要过多考虑回收的问题；

而Java堆和方法区则不一样，一个接口的多个实现类需要的内存不一样，一个方法中多个分支需要的内存也不一样，
我们只有在程序运行期间才能知道会创建哪些对象，这部分的内存分配都是动态的，垃圾收集器关注的就是这部分；

## 3.2 对象已死么
Java堆中保存着几乎所有的对象实例，垃圾收集器在对堆中对象回收前，首先检查哪些对象存活，哪些对象已经死去(不可能再被任何途径使用)；

### 3.2.1 引用计数算法 Reference Counting
给对象添加一个初始值为0的计数器，每当有一个地方引用它，计数器+1，当引用失效时候，计数器-1，任何时刻计数器为0的对象就是不可能再被使用的；

引用计数算法是一种实现简单，判定效率高的算法，但其不能解决对象循环引用的问题；

### 3.2.2 可达性分析算法 Reachability Analysis
通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始往下搜索，搜索所走过的路径称为引用链(Reference Chain),
当一个对象到GC Roots没有任何Reference Chain相连，则认为该对象是不可用的；

Java中可作为GC Roots的对象:
- 虚拟机栈(栈帧中的本地变量表)中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI(即一般所说的native方法)引用的对象；

### 3.2.3 再谈引用
在jdk1.2之前的引用的定义：如果reference类型的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表着一个引用；
但是这种定义太过狭隘，一个对象只能有引用和未引用两种状态；对于一些“食之无味，弃之可惜”
的对象，内存足够时候，应保持引用，gc后内存依然不足的，则可以回收这些对象；

1.2之后，Java对引用的概念进行扩展，分为4种，这四种引用强度依次主键减弱：
- 强引用(Strong Reference) 在程序代码中普遍存在的，类似“Object a = new Object()"这类的引用，
只要强引用还存在，垃圾收集器就不会回收被引用的对象；
- 软引用(Soft Reference) 用来描述一些还在用但非必要的对象；对于软引用关联的对象，
在系统即将发生内存溢出之前，会将这些对象放入回收范围之内，进行二次回收，如果这次回收后，
依然没有足够内存，则会抛出内存溢出；jdk1.2之后，提供SoftReference类来实现引用；
- 弱引用(Weak Reference) 用来描述非必须对象；被弱引用关联的对象只能存活到下一次gc之前，无论内存是否足够，
被弱引用引用的对象都将被回收；jdk1.2之后提供了WeakReference类来实现弱引用；
- 虚引用(Phantom Reference) 也成为幽灵引用或幻影引用，是最弱的一种引用关系；一个对象是否有虚引用，完全不会对其生命周期有影响，
也无法通过虚引用来获取对象实例；为一个对象设置虚引用，只会在这个对象被回收时候收到一个系统通知；jdk1.2之后，
提供了PhantomReference类实现虚引用；

### 3.2.4 生存还是死亡
即使可达性分析算法中不可达的对象，也并非是“非死不可“的，这时候它们处于”缓刑”阶段，真正宣告一个对象死亡，
需要经过两次标记过程：

> 第一次标记

如果对象没有于GC Roots相关联的引用链，name它将会第一次被标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法，
当对象没有覆盖finalize()方法，或者finalize()方法已经被jvm吊用过，虚拟机都将视为“没有必要执行”；

如果有必要执行finalize()方法，这个对象将被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机创建的、低优先级的Finalizer线程去调用F-Queue中的对象的finalize()方法；
但是jvm并不保证会等待它运行结束；因为finalize()方法可能会执行缓慢或者发生死循环,导致F-Queue后边的对象处于永久等待，甚至导致整个内存回收系统崩溃；

> 第二次标记

稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象变为在引用链上，则将其移出即将回收的集合，如果对象没能逃脱，
未能在引用链上，那基本上它就真的被回收了；

gc回收的代码[查看代码](https://github.com/KermitSun/practice/blob/master/java/jvm/第三章/FinalizeEscapeGC.java)

从代码可以看出，SAVE_HOOK对象的finalize()确实被GC收集器触发过，并且在收集前成功逃脱，而第二次gc时候，并不会调用finalize(),所以对象被回收了；

不建议使用finalizy()方法拯救对象，因为它不像C/C++中的析构函数；其运行大家高昂，不确定性大，无法保证各个对象的调用顺序；

### 3.2.5 回收方法区
