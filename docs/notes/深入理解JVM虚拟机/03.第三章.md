# 第三章 垃圾收集器与内存分配策略

## 3.1 概述
垃圾收集器(Garbage Collection, GC),1960年诞生于MIT的Lisp，历史比Java久远；

### GC的作用
程序计数器、虚拟机栈、本地方法栈随着线程产生而存在，线程死亡而消亡，栈中栈帧随着方法
进入和退出有条不紊的入栈和出栈操作，每一个栈帧分配多少内存在类结构确定下来时已经知道
(运行期JIT会进行一些优化，目前可认为是编译器可知的)，因此这几个区域的内存分配和回收都有确定性，
不需要过多考虑回收的问题；

而Java堆和方法区则不一样，一个接口的多个实现类需要的内存不一样，一个方法中多个分支需要的内存也不一样，
我们只有在程序运行期间才能知道会创建哪些对象，这部分的内存分配都是动态的，垃圾收集器关注的就是这部分；

## 3.2 对象已死么
Java堆中保存着几乎所有的对象实例，垃圾收集器在对堆中对象回收前，首先检查哪些对象存活，哪些对象已经死去(不可能再被任何途径使用)；

### 3.2.1 引用计数算法 Reference Counting
给对象添加一个初始值为0的计数器，每当有一个地方引用它，计数器+1，当引用失效时候，计数器-1，任何时刻计数器为0的对象就是不可能再被使用的；

引用计数算法是一种实现简单，判定效率高的算法，但其不能解决对象循环引用的问题；

### 3.2.2 可达性分析算法 Reachability Analysis
通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始往下搜索，搜索所走过的路径称为引用链(Reference Chain),
当一个对象到GC Roots没有任何Reference Chain相连，则认为该对象是不可用的；

Java中可作为GC Roots的对象:
- 虚拟机栈(栈帧中的本地变量表)中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI(即一般所说的native方法)引用的对象；

### 3.2.3 再谈引用
在jdk1.2之前的引用的定义：如果reference类型的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表着一个引用；
但是这种定义太过狭隘，一个对象只能有引用和未引用两种状态；对于一些“食之无味，弃之可惜”
的对象，内存足够时候，应保持引用，gc后内存依然不足的，则可以回收这些对象；

1.2之后，Java对引用的概念进行扩展，分为4种，这四种引用强度依次主键减弱：
- 强引用(Strong Reference) 在程序代码中普遍存在的，类似“Object a = new Object()"这类的引用，
只要强引用还存在，垃圾收集器就不会回收被引用的对象；
- 软引用(Soft Reference) 用来描述一些还在用但非必要的对象；对于软引用关联的对象，
在系统即将发生内存溢出之前，会将这些对象放入回收范围之内，进行二次回收，如果这次回收后，
依然没有足够内存，则会抛出内存溢出；jdk1.2之后，提供SoftReference类来实现引用；
- 弱引用(Weak Reference) 用来描述非必须对象；被弱引用关联的对象只能存活到下一次gc之前，无论内存是否足够，
被弱引用引用的对象都将被回收；jdk1.2之后提供了WeakReference类来实现弱引用；
- 虚引用(Phantom Reference) 也成为幽灵引用或幻影引用，是最弱的一种引用关系；一个对象是否有虚引用，完全不会对其生命周期有影响，
也无法通过虚引用来获取对象实例；为一个对象设置虚引用，只会在这个对象被回收时候收到一个系统通知；jdk1.2之后，
提供了PhantomReference类实现虚引用；

### 3.2.4 生存还是死亡
即使可达性分析算法中不可达的对象，也并非是“非死不可“的，这时候它们处于”缓刑”阶段，真正宣告一个对象死亡，
需要经过两次标记过程：

> 第一次标记

如果对象没有于GC Roots相关联的引用链，name它将会第一次被标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法，
当对象没有覆盖finalize()方法，或者finalize()方法已经被jvm吊用过，虚拟机都将视为“没有必要执行”；

如果有必要执行finalize()方法，这个对象将被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机创建的、低优先级的Finalizer线程去调用F-Queue中的对象的finalize()方法；
但是jvm并不保证会等待它运行结束；因为finalize()方法可能会执行缓慢或者发生死循环,导致F-Queue后边的对象处于永久等待，甚至导致整个内存回收系统崩溃；

> 第二次标记

稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象变为在引用链上，则将其移出即将回收的集合，如果对象没能逃脱，
未能在引用链上，那基本上它就真的被回收了；

gc回收的代码[查看代码](https://github.com/KermitSun/practice/blob/master/java/jvm/第三章/FinalizeEscapeGC.java)

从代码可以看出，SAVE_HOOK对象的finalize()确实被GC收集器触发过，并且在收集前成功逃脱，而第二次gc时候，并不会调用finalize(),所以对象被回收了；

不建议使用finalizy()方法拯救对象，因为它不像C/C++中的析构函数；其运行大家高昂，不确定性大，无法保证各个对象的调用顺序；

### 3.2.5 回收方法区
方法区(HotSpot中的永久代)的回收性价比不高，Java虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾收集，方法区的垃圾回收主要是两部分，废弃常量和无用的类；

对于废弃常量的判断较为简单，以常量池中字面量做例子，如果一个字符串"abc"已经进入常量池，但是当前系统没有任何一个String对象引用常量池中的"abc"常量,那么发生内存回收时候，
如果有必要，该常量就会被清理出常量池；

对于无用的类的判断，则要复杂很多，需要同时满足以下要求：
- 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；

虚拟机可以对满足上述3个条件的无用类进行回收，但不是必然，HotSpot通过-Xnoclassgc参数设置是否回收；

## 3.3 垃圾收集算法
### 3.3.1 标记-清除算法 Mark-Sweep
算法分为"标记"和"清除"两个阶段，首先标记出所有需要回收的对象，然后统一回收所有被标记的对象，它的标记过程就是前一节讲的两次标记过程；

标记清除算法的不足：
- 效率慢，标记和清除的过程效率都不高；
- 空间利用率低，标记清除后会产生大量不连续的内存碎片，后续如果程序申请一个较大对象空间时候，无法找到一块足够的内存空间，就会触发再一次的垃圾收集动作；

### 3.3.2 复制算法 Copying
为了解决效率问题，复制算法出现了，它将可用内存按容量分为大小相等的两部分，每次只使用其中一块；当这块内存用完了，就将还存活着的对象复制到另一块上面，
然后把当前的内存块一次清理掉；

复制算法不会产生内存碎片，分配新的内存时候，也只需要指针碰撞就行了，实现简单，运行高效；

其不足是内存缩小为原来的一半，代价较高；

现在的商用虚拟机都是采用复制算法来回收新生代的，新生代中98%的对象都是朝生夕死的；

虚拟机实现复制算法时，并不是按1:1分配两块内存空间，而是分为了一个较大的Eden空间和两个较小的Survivor空间，每次只使用一个Eden和一个Survior空间，
当垃圾回收时，将两块空间存活的对象一次性放入另一个Survivor空间，并清理当前的两个内存空间；

HotSpot默认的Eden和Survivor的比例是8:1，这样新生代的内存空间只会浪费10%；当Survivor空间不足，不足以存放存活对象时候，
需要依赖其他内存空间(这里指老年代)进行分配担保(Handle Promotion);

### 3.3.3 标记-整理算法 Mark-Compact
标记-整理算法分为"标记""清除"和"整理"，标记-清除如同之前，最后会进行整理，将所有存活的对象左移，取消内存碎片；

### 3.3.4 分代收集算法 Generational Collection
当前商业虚拟机的垃圾收集都采用“分代收集”算法，其根据对象的存活周期的不同将内存划分为几块；一般讲Java堆分为新生代和老年代，
根据各个年代不同特点采用不同垃圾收集算法；

在新生代中，每次垃圾收集都会发现大批死去的对象，只有少量存活，所以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，
而老年代中对象的存活率高、没有额外空间对它进行分配担保，就必须采用"标记-清除"或"标记-整理"算法来进行收集了；

## 3.4 HotSpot的算法实现
## 3.4.1 枚举根节点
可达性分析中