## OSI七层协议
1. 物理层  
机械、电子、定时接口通信信道上的原始比特流传输；
2. 数据链路层
物理寻址、同时将原始比特流转为逻辑传输路线，提供错误检测和纠正；
3. 网络层
控制子网的运行，如逻辑编址、分组传输、路由选择，IP协议在此层；
4. 传输层
接受上层的数据，在必要的时候把数据进行切分，并将这些数据交给网络层，并保证这些数据段有效到达对端；
tcp传输控制协议和udp传输控制协议在此层；
5. 会话层
不同机器s上的用户之间建立及管理会话；
6. 表示层
信息的语法语义以及他们的关联，如加密解密、转换翻译、压缩解压缩；
7. 应用层
规定发送方和接收方使用固定长度的消息头，消息头里应有固定的几个信息，如消息体长度；http协议在这一层；

## OSI协议的实现：TCP/IP协议
<table>
    <tr>
        <th>OSI七层协议</th>
        <th>TCP/IP概念层模型</th>
        <th>功能</th>
        <th>TCP/IP协议族</th>
    </tr>
    <tr>
        <td>应用层</td>
        <td rowspan="3">应用层</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>表示层</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>会话层</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>传输层</td>
        <td>传输层</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>网络层</td>
        <td>网络层</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>数据链路层</td>
        <td rowspan="3">链路层</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>物理层</td>
        <td>1</td>
        <td>2</td>
    </tr>
</table>

## TCP 三次握手和四次挥手

在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，四次挥手断开连接；

三次握手流程图：
![tcp三次握手流程图](/resources/images/java/tcp三次握手流程图.png)

第一次握手，客户端发送SYN包(seq=i)到服务器，并且进入SYN_SEND状态，等待服务器确认；

第二次握手，服务器收到SYN包，返回一个[SYN，ACK]包(ack=i+1,seq=j),此时服务器进入SYN_RECV状态；

第三次握手，客户端收到服务器的[SYN,ACK]包，向服务器发送确认包ACK(ack=j+1),此包发送完毕，客户端和服务器进入ESTABLISHED状态；

三次握手流程结束，客户端和服务器建立了连接；

三次握手主要是要初始化Sequence Number(简称seq)的值，代表着字段的初始位置，seq保证了数据的有序性；
而返回的ACK包中包含了SYN包里的seq+1的值，是为了让接收方校验是否返回正确；

#### TCP三次握手之间的问题
> 第三次握手未发送成功，如何处理？
>> 第三次握手失败后，服务器会再次发送[SYN,ACK]包，等待客户端回应，这种重试在linux中
会执行5此，间隔时间是1s,2s,4s,8s,16s,第五次发送完成后还会等待32s回应，一共63s,如果没回应，
则断开连接；

> 服务器多次发送[SYN,ACK]的问题？
>> 恶意客户端在第一次握手发送SYN报文后，直接断开连接，造成服务器该连接锁死63s，
多次访问，使得服务器端的SYN队列挤满，正常客户端无法连接服务器；linux下，SYN队列满额之后，
通过tcp_syncookies参数设置，生成SYN Cookie，并且发送给客户端，如果有响应，则直接建立连接，
没响应，则断开连接；

> 建立连接后，客户端突然掉线的处理
>> 保活机制，向对方发送保活探测报文，没响应继续，达到保活探测数依然没响应，则断开连接；

四次挥手流程图：
![tcp四次挥手流程图](/resources/images/java/tcp四次挥手流程图.png)

第一次挥手：客户端发送一个FIN(seq=m)，用来关闭客户端到服务器的数据传输，客户端进入FIN_WAIT_1状态，此状态客户端不能再传输业务数据；

第二次挥手：服务端收到FIN后，发送一个ACK(seq=n,ack=m+1)到客户端 ，服务器进入CLOSE_WAIT状态，将不在接受客户端的业务数据；

第三次挥手：服务器完成传输后，向客户端发送一个[FIN,ACK]包(seq=x,ack=m+1),服务器进入LAST_ACK状态，此状态服务器不再发送业务数据到客户端；

第四次挥手：客户端收到[FIN,ACK]包后，进入TIME_WAIT状态，接着发送一个ACK(ack=x+1)给服务器，服务器接收到会进入CLOSED状态；

TIME_WAIT：一般为2ms，客户端在2ms后进入CLOSED状态，2ms是因为要确保让服务器有足够的时间接收到ACK,并且有的路由器会缓存连接，2ms是为了不和后面的连接
数据出现重复(延迟收包);

## UDP

UDP是面向非连接，不维护连接状态，支持同时向多个客户端传输相同的数据；

UDP的报头只有8字节，额外开销小，传输快，但不能保证发送成功，并且无重试机制；

## http

应用层传输协议

## https

## socket


