#第二章 Java内存区域与内存溢出异常

## 运行时数据区域
JVM在执行Java程序时候将内存划分为多个区域，每个区域有自己的用途、创建时间、销毁时间；

以下是《Java虚拟机 Java SE 7版》的规定，具体虚拟机实现与规范有部分不一致；

### 程序计数器 Program Counter Register
线程私有的较小内存区域，记录当前线程所执行字节码的行号；

如果线程正在执行Java程序，这个计数器记录的是正在执行的虚拟机字节码指令的地址，
如果执行native方法，这个计数器为空(Undefined)；

此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域；

### Java虚拟机栈 Java Virtual Machine Stacks
线程私有，生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型;

每个方法在执行的同时会创建一个栈帧(Stack Frame),用于存储局部变量表、操作数栈、动态链接、方法出口等；

每个方法从调用到执行完成，意味着一个栈帧从入栈到出栈的过程；

局部变量表存储着编译器可知的各种基本数据类型(boolean、char、short、byte、int、long、float、double)、
对象的引用(reference类型，可能是指向对象起始位置地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置)、
returnAddress类型(指向了一条字节码指令的地址)；

局部变量表的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的；

Java虚拟机规范中规定了两种异常：
- 如果线程请求的栈深度大于虚拟机允许深度，将抛出stackOverflowError异常；
- 如果虚拟机栈可以动态扩展，扩展时候无法申请到足够内存，将抛出OutOfMemoryError异常；

### 本地方法栈 Native Method Stack
基本与虚拟机栈相同，不同之处是：本地方法栈服务于native方法；

Sun Spot虚拟机将本地方法栈和虚拟机栈合二为一；

### Java堆 Java Heap
线程共享，虚拟机启动时候创建；

所有的对象实例和数组都要在堆上分配内存，但是随着JIT编译器和逃逸分析技术逐渐成熟，栈上分配、
标量替换优化技术将会导致一些微妙的变化，所有对象分配到堆上不是那么绝对了；

从内存回收的角度，收集器基本都采用分代手集算法，所以Java堆可分为：新生代和老生代；再细致一点可分为：
Eden(/ˈiːdn/ 伊甸园)空间、From Survivor( /sə'vaɪvə/  幸存者)空间、To Survivor空间；

从内存分配的角度，可分为多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB);

Java堆可以在物理上是不连续的空间，只要逻辑上连续即可；

Java堆可以是固定大小的，也可以是可扩展的，通过-Xmx和-Xms控制；

如果堆中没有内存完成实例分配，并且无法扩展时候，将抛出OutOfMemoryError异常；

### 方法区 Method Area
线程共享，用于保存已被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等；

Java虚拟机规范将方法区归为堆的一个逻辑部分，但它有个别名叫做Non-Heap(非堆);

HotSpot中，将GC分代收集扩散至方法区，或者说使用永久代来实现方法去而已，可以省去
为方法区写专门的垃圾回收算法，所以HotSpot中常说的永久代指的就是方法区；对于其他
虚拟机来说，是不存在永久代的；

当方法区无法申请到内存时，将抛出OOM异常；

### 运行时常量池 Runtime Constant Pool
运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；

Java虚拟机规范没有对运行时常量池做任何详细要求，一般来说，除了保存Class中
描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中；

运行时常量池具备动态性，不止编译期能产生，运行期间也能将新的常量放入池中，
比如说String.intern();

常量池数据方法区，所以也会抛出OOM异常；

### 直接内存 Direct Memory
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，
而是数据本机内存；

jdk1.4引入的NIO(New Input/Output)类，引入了一种基于通道(Channel)和缓冲区(Buffer)的I/O
方式，它可以使用Native函数库直接分配堆外内存，然后通过Java堆中的DirectByteBuffer对象作为这块
内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据；

直接内存受到本机总内存(RAM以及SWAP区或者分页文件)大小以及处理器寻根空间的限制，当Java管理的内存+直接内存
超过了物理内存限制(包括物理和操作系统的限制)，从而导致动态扩展时出现OOM异常；

## HotSpot虚拟机对象探秘
HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程

### 对象的创建(不包括数组和Class对象)
虚拟机遇到一个new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个类是否被加载、解析、初始化；
如果没有，那就必须先执行类加载过程；

类加载检查后，虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后便可确定；
- 如果Java堆中内存是绝对规整的，所有用过的放在一边，未使用的内存放在另外一边，
中间放一个指针作为分界点的指示器，那所分配内存就仅仅是把指针向空闲内存方向挪动一段对象
内存大小的距离，这种分配方式称为“指针碰撞"(Bump the Pointer);
- 如果堆内存不是规整的，已使用和空闲的内存是相互交错的，虚拟机需要维护一个列表，
记录哪块内存是可用的，在分配内存的时候从列表中找到一块足够大的空间划分给对象实例，
并更新表上记录，这种分配方式称为“空闲列表”(Free List);

选择哪种方式由Java堆是否规整决定，而