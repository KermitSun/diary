#第二章 Java内存区域与内存溢出异常

## 运行时数据区域
JVM在执行Java程序时候将内存划分为多个区域，每个区域有自己的用途、创建时间、销毁时间；

以下是《Java虚拟机 Java SE 7版》的规定，具体虚拟机实现与规范有部分不一致；

### 程序计数器 Program Counter Register
线程私有的较小内存区域，记录当前线程所执行字节码的行号；

如果线程正在执行Java程序，这个计数器记录的是正在执行的虚拟机字节码指令的地址，
如果执行native方法，这个计数器为空(Undefined)；

此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域；

### Java虚拟机栈 Java Virtual Machine Stacks
线程私有，生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型;

每个方法在执行的同时会创建一个栈帧(Stack Frame),用于存储局部变量表、操作数栈、动态链接、方法出口等；

每个方法从调用到执行完成，意味着一个栈帧从入栈到出栈的过程；

局部变量表存储着编译器可知的各种基本数据类型(boolean、char、short、byte、int、long、float、double)、
对象的引用(reference类型，可能是指向对象起始位置地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置)、
returnAddress类型(指向了一条字节码指令的地址)；

局部变量表的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的；

Java虚拟机规范中规定了两种异常：
- 如果线程请求的栈深度大于虚拟机允许深度，将抛出stackOverflowError异常；
- 如果虚拟机栈可以动态扩展，扩展时候无法申请到足够内存，将抛出OutOfMemoryError异常；

### 本地方法栈 Native Method Stack
基本与虚拟机栈相同，不同之处是：本地方法栈服务于native方法；

Sun Spot虚拟机将本地方法栈和虚拟机栈合二为一；

### Java堆 Java Heap
线程共享，虚拟机启动时候创建；

所有的对象实例和数组都要在堆上分配内存，但是随着JIT编译器和逃逸分析技术逐渐成熟，栈上分配、
标量替换优化技术将会导致一些微妙的变化，所有对象分配到堆上不是那么绝对了；

从内存回收的角度，收集器基本都采用分代手集算法，所以Java堆可分为：新生代和老生代；再细致一点可分为：
Eden(/ˈiːdn/ 伊甸园)空间、From Survivor( /sə'vaɪvə/  幸存者)空间、To Survivor空间；

从内存分配的角度，可分为多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB);

Java堆可以在物理上是不连续的空间，只要逻辑上连续即可；

Java堆可以是固定大小的，也可以是可扩展的，通过-Xmx和-Xms控制；

如果堆中没有内存完成实例分配，并且无法扩展时候，将抛出OutOfMemoryError异常；

### 方法区 Method Area
线程共享，用于保存已被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等；

Java虚拟机规范将方法区归为堆的一个逻辑部分，但它有个别名叫做Non-Heap(非堆);
