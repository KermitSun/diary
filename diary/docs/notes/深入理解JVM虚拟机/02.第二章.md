#Java内存区域与内存溢出异常

## 运行时数据区域
JVM在执行Java程序时候将内存划分为多个区域，每个区域有自己的用途、创建时间、销毁时间；

以下是《Java虚拟机 Java SE 7版》的规定，具体虚拟机实现与规范有部分不一致；

### 程序计数器
线程私有的较小内存区域，记录当前线程所执行字节码的行号；

如果线程正在执行Java程序，这个计数器记录的是正在执行的虚拟机字节码指令的地址，
如果执行native方法，这个计数器为空(Undefined)；

此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域；

### Java虚拟机栈
线程私有，生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型;

每个方法在执行的同时会创建一个栈帧(Stack Frame),用于存储局部变量表、操作数栈、动态链接、方法出口等；

每个方法从调用到执行完成，意味着一个栈帧从入栈到出栈的过程；

局部变量表存储着编译器可知的各种基本数据类型(boolean、char、short、byte、int、long、float、double)、
对象的引用(reference类型，可能是指向对象起始位置地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置)、
returnAddress类型(指向了一条字节码指令的地址)；

局部变量表的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的；

Java虚拟机规范中规定了两种异常：
- 如果线程请求的栈深度大于虚拟机允许深度，将抛出stackOverflowError异常；
- 如果虚拟机栈可以动态扩展，扩展时候无法申请到足够内存，将抛出OutOfMemoryError异常；

### 本地方法栈
基本与虚拟机栈相同，不同之处是：本地方法栈服务于native方法；

Sun Spot虚拟机将本地方法栈和虚拟机栈合二为一；

### Java堆
线程共享，虚拟机启动时候创建；